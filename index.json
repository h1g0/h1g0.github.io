[{"title":"About","date":"","description":"","body":"hi_go ( /çiɡo/ )  A photo of me.    GitHub: @h1g0 Mail: me (at) clutte.red GPG Public key: 4856 5132 065F 40F6 0441 63A0 6D5C 9C7E 29BA E7EE Résumé / CV: Please contact me.  Attribution Theme: Hugo Future Imperfect Slim\nA HTML5 UP port\nPowered by Hugo\n","ref":"/about/"},{"title":"[Rust] Bevyでブラウザ上で動くライフゲームを作った","date":"","description":"","body":"Rust用ゲームエンジンであるBevyを使って、ブラウザ上で動くライフゲームを作ってみた。\n「続きを読む」以下に実際に動作するデモが置いてある。\n動作デモ  ソースコード Github\n","ref":"/blog/2021/12/wasm-rs/"},{"title":"sudachi.rsを使って遊んでみる（ための下準備）","date":"","description":"","body":"sudachi.rsという、Rustで実装された形態素解析器がある。それをライブラリとして何か書いて遊ぶための下準備的なメモ。\nsudachi.rsとは Sudachiという形態素解析器（実装はJava）のRustによる非公式クローン。 詳しくは作者の方のブログエントリを参照してほしい。\nSudachiには他にもPythonによる実装（公式）やGoによる実装（非公式）があるようだ。\n実際に遊んで見る sudachi.rsはまだcrates.ioに登録されていない1。 そのため、自分でソースコードをcloneしておく必要がある。\n$ git clone https://github.com/sorami/sudachi.rs.git また、辞書をこちらからダウンロードして展開しておく。\n辞書の配置ディレクトリは（プログラムから呼べる場所であれば）どこでも良いが、ここではsudachi.rsのREADMEに従ってsudachi.rs/src/resources/system.dicとした。\n次に、先程sudachi.rsをクローンしたのと同じディレクトリで\n$ cargo new --bin sudachi_test こんな感じで、適当な名前で新しいプロジェクトを作る。\nそしたら中のCargo.tomlに\n[dependencies.sudachi] path = \u0026#34;../sudachi.rs/\u0026#34; こんな感じでsudachi.rsへの相対パスを教えてやる。\nそしてsrc/main.rsを開き、\nextern crate sudachi; use sudachi::tokenizer::Mode; use sudachi::tokenizer::Tokenizer; fn main() { let txt = \u0026#34;東海の小島の磯の白砂にわれ泣きぬれて蟹とたはむる\u0026#34;; let bytes = include_bytes!(\u0026#34;../../sudachi.rs/src/resources/system.dic\u0026#34;); let tokenizer = Tokenizer::new(bytes); let morpheme_list = tokenizer.tokenize(\u0026amp;String::from(txt), \u0026amp;Mode::C, false); for morpheme in morpheme_list{ println!(\u0026#34;{}（{}）\u0026#34;,morpheme.surface(),morpheme.reading_form() ); } } こんな感じでコードを書いてやる2。\ncargo runで実行すると、\n東海（トウカイ） の（ノ） 小島（コジマ） の（ノ） 磯（イソ） の（ノ） 白砂（ハクシャ） に（ニ） われ（ワレ） 泣きぬれ（ナキヌレ） て（テ） 蟹（カニ） と（ト） たはむる（タハムル） と、実に簡単に分かち書きと読みがなの付与ができた3。\n利用できる関数 分割された各形態素に対して利用できる関数は次の通り4。\n surface:分割された後の形態素 pos:その形態素に関する情報 normalized_form: 正規化された形 reading_form: 読みがな dictionary_form: 辞書形  ここまでの感想 わずか数行のコードで、とても簡単にRustでの自然言語処理の第一歩を踏み出すことができた。 ここから更に色々遊べそうである。\n追記 sudachiclone-rsという、別の方が作成したSudachiのRustクローン5もあるらしい。 そしてこちらはcrates.ioに登録されているようだ。\n    作者の方もissueとして認識してはいるようである。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 辞書ファイルへのパスが長すぎるので、置く場所を自プロジェクトのディレクトリ内にしてもよかったかもしれない。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 「白砂（しらすな）」を「はくしゃ」としているが、これは十分許容範囲であるように思われる。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/sorami/sudachi.rs/blob/develop/src/morpheme.rs\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 正確にはSudachiPyのRustクローン\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2020/04/play-with-sudachi-rs/"},{"title":"HHKB Professional HYBRID Type-Sを買った","date":"","description":"","body":"1ヶ月ほど前にHappy Hacking Keyboard (HHKB) Professional HYBRID Type-Sを買った。 なので買った経緯とか1ヶ月使った感想（簡単なレビュー）とか現在のキーマッピングとかをメモしていきたい。\n購入に至る経緯 自分は今まで仕事ではHHKB Professional2 Type-Sを、 自宅ではMajestouch MINILA Airを使っていた。\nそんな中、昨今のリモートワークの流れで、自分も自宅で仕事をせざるを得なくなった。 そこで「いつもやっている仕事は、やはりHHKBでやりたい」ということで、自宅にHHKBを持ち帰った。\nところが、自宅は職場よりも机が狭く、キーボードとコーヒーを近接して置かざるを得なかった。 案の定、リモートワークを初めて1週間経たないうちにHHKBにコーヒーをこぼしてしまった。 表面上の被害は軽微だったように見えたため、軽く拭き取ってそのままにしていたのだが、しばらくするとHHKBが誤作動1するようになってしまった。\n慌てて中の基板を確かめたところ、基板までコーヒーが浸水してしまっており、 どうやらそれが原因で基板が駄目になってしまったようだった。\n調べたところ、HHKBは公式では修理を行っていないらしい。 エンジニアの自分にとってキーボードは商売道具と言っても過言ではないため相当ヘコんだが、 去年の12月にHHKBの新シリーズ「HYBRID」が発売されていたことを知っていたため、そちらの購入を決意した2。\n購入した理由としては以下の通りである。\n HHKBの打鍵感は他のキーボードの追随を許さない唯一無二のものであると考えていること。 HYBRIDはキーマッピングのカスタマイズができる点がウリの1つであったこと  1ヶ月ほど使用してみた感想 打鍵感はほぼ期待通りであった。旧HHKB（自分が持っているProfessional2 Type-S）と比較すると、やや打鍵感が異なるように思え、若干疲れやすくなった気がしないでもない。 しかし、それでも他のキーボードよりも優れているとは思う。\nBluetooth接続は問題なく機能している。最大4台の接続情報を記憶しておき、Fn + Ctrl + 1～4 キーで接続を切り替えられるのも便利である。\nキーマッピングに関してはかなり期待していたのだが、やや期待はずれであった（後述）。\nキーマッピング 現在の自分の Fn レイヤーのキーマッピングはこんな感じである。通常レイヤーは変更点は無い。\n      概要としては\n 左手のホームポジション周辺 E, S, D, F キーにそれぞれカーソルキーを配置。これはMajestouch MINILAがこの設定であり、右端にあるHHKBよりも便利だからである。 HHKB本来のカーソルキーもよく使用するため、そのまま残した。 カーソルキーの右上と左上には PgUp, PgDn キーを配置。これは自分が好きなThinkPadシリーズのキー配列がこうなっており、便利だからである。 右手のホームポジション周辺 H, J, KにそれぞれBS,Ent,Delキーを配置。よく使うキーにも関わらず、ホームポジションから遠い位置にあるのが気に入らなかったためである。  こんな感じ。\nキーマッピングの問題点 右Fnキー、Controlキー、Qキーなど、一部のキーはキーマッピングを設定できない。 これらの設定を変更できないキーはソフトウェア上で「☒」アイコンになっているが、それ以外にもZ キーなど、 一見すると設定変更可能であるように見えるキーの中に、なぜか設定変更できないキーが存在する。\nこれらのキーについて、公式では\n ※特別な機能を割り当てられた一部のキーを除く。\n と記述があるのみであり、 「具体的にどのキーの設定が変更できないのか」 が明示されていない。\nこれは「自分の理想とするキーマッピングを実現できるのか否か」によって購入するかを判断するユーザにとっては大きな関心事であり、 その点の情報が公式から公開されていない、というのは問題であるように思われる。\n今後の希望 少なくとも、「具体的にどのキーの設定が変更できないのか」を予め公式サイトでアナウンスしてほしい。 理想論としては、今後のファームウェアアップデートなどで、全てのキーを設定変更可能にしてほしい。\n後は完全な妄言ではあるが、 Majestouch MINILAの「親指ダブルFnキー」はHHKBには無い優れたキー配置であると思っている。 HHKBも、それかそれに近いキー配置の製品を発売してほしい。\nもっとも、親指ダブルFnキーはFILCOの公式サイトで\n 【意匠権取得済み】\n とアピールしており、他の会社が追従するのは（権利上）難しいのかもしれない。\nサードパーティや同人で改造キットを出してくれる所があれば嬉しいなあ……。\n追記 使い始めてから1ヶ月と1週間ほど経ったところで、バッテリ（購入時に付属していた単3電池×2）が切れた。 メーカーの公称値では\n アルカリ乾電池使用時の目安：約3カ月（当社環境でのテスト値であり、保証値ではありません）\n となっており、それと比べるとだいぶ短いような気もする。 しかし\n 毎日12時間程度使っていた 省電力モードをオフ（DIPスイッチ6をON）にしていた3  ことを考えると、まあこんなものかなあ、という気もする。\nそして内蔵バッテリではなく敢えて単3電池という選択をしたのは素晴らしいと思う。 HHKBは何年も使うものである一方、内蔵バッテリは劣化の不安があり、劣化した場合の交換が面倒なことが予期されるためである。\n単3電池であれば入手も交換も用意であるし、いちいち電池を買うのが面倒であれば\n このようなリチャージャブルな電池を使うという選択肢もある。 また、もし使用中にバッテリが切れてしまった場合でも、USBに接続すれば使用し続けることが可能なのも安心できる（ちなみに、モバイルバッテリからHHKBのUSBポートに接続して給電することも可能である）。\n   特定のキーが常に押されっぱなしになるなど\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n なお、新しいHHKBを注文したあとで、コーヒーをこぼしてしまった基板をダメ元でウェットティッシュ（アルコール）で丹念に拭いてしばらく乾かしてみたところ、何もごともなかったかのように復活した。したがって（今後リモートワークが解除されたら）職場と家の両方でHHKBを使うことができるようになった。嬉しい誤算である。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 省電力モードをオン（デフォルト）にすると、BT接続した場合でしばらく放置した場合に自動的に電源が切れる。そして入力前に電源ボタンを長押して電源を入れなければならず少し面倒。オフにすると、どれかのキーを押すだけでBTを再接続する。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2020/04/bought-new-hhkb/"},{"title":"Hello, Hugo!","date":"","description":"","body":"このサイトのフレームワークをWordPressからHugoに乗り換えてみた。\nその理由として、\n Markdownでコンテンツを書ける Gitで管理できる そのため、GitHub Pagesでホスティングできる WordPressはウェブサイトを動的に生成するため、サイトの構成やサーバのスペック等によっては動作が重い。また、脆弱性も懸念点となる Hugoは静的サイトジェネレータであるため、WordPressよりも軽量な動作が期待できる  などが挙げられる。\nそしてこちらのGitHub Actionsを使うことで、書いたMarkdownをGitHub上のリモートリポジトリにpushすると自動的にHugoを走らせ、生成物をウェブサイトにデプロイするようにできた。大変便利。\nしばらくこれでやってみよう。\n","ref":"/blog/2020/04/test/"},{"title":"[Python] filecmpの引数shallowの細かい仕様について","date":"","description":"","body":"Pythonのfilecmpは引数にshallow = True を付ける（デフォルト）と「浅い」ファイル比較を行う。この際に何を参照して「同じファイル」と判断するのか調べる必要があったのでメモ。 なお、この記事はPython 3.7 時点での情報である。\n結論から言うと、ファイルサイズと最終更新日時が同一ならば同一のファイルとして判断される。\n解説として、「浅い」ファイル比較はファイルごとにシグネチャを生成し、それらが同じならば同じファイルであると判断する。そしてその際の生成コードが\n_sig(st): return (stat.S_IFMT(st.st_mode), st.st_size, st.st_mtime) となっている1。\n引数のstはos.stat_resultオブジェクトであるので、st_mode、 st_size、 st_mtimeの3つから同じファイルか判断していることになる。\nこのうち、 st_modeはファイルタイプとファイルモード2の判定であるので、実質的にはst_size、つまりファイルサイズと、st_mtime、つまり最終更新日時で判定していることになる。\nなお、shallow = Falseとして「深い」ファイル比較を行うと、文字通り バイト単位でファイルの同一性をチェックする。当然ながら「浅い」ファイル比較よりも処理に時間がかかるが、より確実性を求める場合はこちらを使用することも検討すべきかもしれない。\n   https://github.com/python/cpython/blob/3.7/Lib/filecmp.py\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ディレクトリか？ファイルか？シンボリックリンクか？etc.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2019/10/python-filecmp-shallow/"},{"title":"[Rust] rustup-inst.exeでの新規インストール時に「アクセスが拒否されました。(os error 5)」が出る時の対処法","date":"","description":"","body":"Windows 10にrustup-inst.exeを使ってRust1をインストールしようとしたところ、アクセスが拒否されました。(os error 5)のエラーが出てインストールできなかった。それを解決した際のメモ。\nなお、インストールしようとしたrustupのバージョンは\nrustup 1.18.3 (435397f48 2019-05-22) である。\n解決法 とりあえずOSの再起動等を試してみても効果がなかったのでググってみたところ、githubのプロジェクトページに\nfresh install fails on Windows: \u0026amp;ldquo;error: could not rename component file from \u0026amp;lsquo;\u0026amp;hellip; ust-docs\\share/doc/rust/html\u0026amp;rsquo; \u0026amp;hellip;\u0026amp;quot;\nというIssueが上がっているのを見つけた。読んでみたところ、自分の問題と同じであった。\nこの記事を参考にアンチウィルスソフト（自分の場合はAvira）のリアルタイムプロテクションを一時的に切ってrustup-inst.exeを再試行したところ、今度は正常にインストールできた。\n以前rustup-inst.exeを使って同環境でセットアップを行った際には問題は発生しなかったので、rustup-inst.exeのアップデートによるものかAviraの更新に起因する問題なのかもしれない。\n    厳密にはrustup\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2019/07/rustup-inst-exe-failed-to-install/"},{"title":"RustでBrainf*ckインタプリタを書いた","date":"","description":"","body":"最近Rustを学び始めた。そこで、RustでHello, world!プログラムを書いた。\nといっても、普通にprintln!(\u0026quot;Hello, world!\u0026quot;);するだけでは何も面白くない。\nなのでBrainf*ckで、インタプリタと一緒に。\nコードは（今のところ）こんな感じ。そしてideoneによる実行結果はこんな感じ。ちなみにGithubにも上げてある。\nuse std::collections::VecDeque; use std::collections::HashMap; enum Token { Inc, Dec, IncPtr, DecPtr, StartLoop, EndLoop, Input, Output, } impl Token{ fn tokenize(c:char) -\u0026gt; Option\u0026lt;Token\u0026gt;{ match c{ \u0026#39;+\u0026#39; =\u0026gt; Some(Token::Inc), \u0026#39;-\u0026#39; =\u0026gt; Some(Token::Dec), \u0026#39;\u0026gt;\u0026#39; =\u0026gt; Some(Token::IncPtr), \u0026#39;\u0026lt;\u0026#39; =\u0026gt; Some(Token::DecPtr), \u0026#39;[\u0026#39; =\u0026gt; Some(Token::StartLoop), \u0026#39;]\u0026#39; =\u0026gt; Some(Token::EndLoop), \u0026#39;,\u0026#39; =\u0026gt; Some(Token::Input), \u0026#39;.\u0026#39; =\u0026gt; Some(Token::Output), _ =\u0026gt; None, } } fn tokenize_from_array(char_array: Vec\u0026lt;char\u0026gt;)-\u0026gt;Vec\u0026lt;Token\u0026gt;{ let mut token_array: Vec\u0026lt;Token\u0026gt; = Vec::new(); for token in char_array.iter().filter_map(|c| Token::tokenize(*c)){ token_array.push(token); } return token_array; } fn get_loop_token_ptr(token_array:\u0026amp;Vec\u0026lt;Token\u0026gt;)-\u0026gt; (HashMap\u0026lt;u32,u32\u0026gt;,HashMap\u0026lt;u32,u32\u0026gt;){ let mut start_end_map : HashMap\u0026lt;u32,u32\u0026gt; = HashMap::new(); let mut end_start_map : HashMap\u0026lt;u32,u32\u0026gt; = HashMap::new(); let mut start_ptr_stack : Vec\u0026lt;u32\u0026gt; = Vec::new(); let mut ptr : u32 = 0; for token in token_array{ match *token{ Token::StartLoop =\u0026gt; { start_ptr_stack.push(ptr); }, Token::EndLoop =\u0026gt; { if let Some(start_ptr) = start_ptr_stack.pop(){ start_end_map.insert(start_ptr, ptr); end_start_map.insert(ptr, start_ptr); }else{ panic!(\u0026#34;Too many \u0026#39;]\u0026#39; tokens detected!\u0026#34;); } }, _ =\u0026gt; {} } ptr+=1; } if ! start_ptr_stack.is_empty(){ panic!(\u0026#34;Too many \u0026#39;[\u0026#39; tokens detected!\u0026#34;); } return (start_end_map, end_start_map); } //fn for token \u0026#39;+\u0026#39;.  fn inc_mem_val(memory :\u0026amp;mut Vec\u0026lt;u32\u0026gt;, memory_ptr:u16){ if let Some(val) = memory.get_mut(memory_ptr as usize) { *val += 1; } } //fn for token \u0026#39;-\u0026#39;.  fn dec_mem_val(memory :\u0026amp;mut Vec\u0026lt;u32\u0026gt;, memory_ptr:u16){ if let Some(val) = memory.get_mut(memory_ptr as usize) { *val -= 1; } } //fn for token \u0026#39;\u0026gt;\u0026#39;.  fn inc_mem_ptr(memory_ptr:\u0026amp;mut u16){ *memory_ptr +=1; } //fn for token \u0026#39;\u0026lt;\u0026#39;.  fn dec_mem_ptr(memory_ptr:\u0026amp;mut u16){ *memory_ptr -=1; } //fn for token \u0026#39;[\u0026#39;.  fn jump_loop_end_token_if_mem_0(mem_val:Option\u0026lt;\u0026amp;u32\u0026gt;, loop_start_end_token_ptr_map:\u0026amp;HashMap\u0026lt;u32,u32\u0026gt;, token_ptr : \u0026amp;mut u32){ if let Some(val) = mem_val{ if *val != 0{return;} }else{return;} if let Some(end_ptr) = loop_start_end_token_ptr_map.get(token_ptr){ *token_ptr = *end_ptr; }else{ panic!(\u0026#34;no pair \u0026#39;]\u0026#39; token found.\u0026#34;); } } //fn for token \u0026#39;]\u0026#39;.  fn jump_loop_start_token_if_mem_not_0(mem_val:Option\u0026lt;\u0026amp;u32\u0026gt;, loop_end_start_token_ptr_map:\u0026amp;HashMap\u0026lt;u32,u32\u0026gt;, token_ptr : \u0026amp;mut u32){ if let Some(val) = mem_val{ if *val == 0{return;} }else{return;} if let Some(start_ptr) = loop_end_start_token_ptr_map.get(token_ptr){ *token_ptr = *start_ptr; }else{ panic!(\u0026#34;no pair \u0026#39;[\u0026#39; token found.\u0026#34;); } } //fn for token \u0026#39;,\u0026#39;.  fn put_char_from_input_to_mem(input_char_array:\u0026amp;mut VecDeque\u0026lt;char\u0026gt;, memory :\u0026amp;mut Vec\u0026lt;u32\u0026gt;, memory_ptr:u16){ if let Some(val) = memory.get_mut(memory_ptr as usize){ if let Some(c) = input_char_array.pop_front() { *val = u32::from(c); } } } //fn for token \u0026#39;.\u0026#39;.  fn join_output_char_to_str(output_char:Option\u0026lt;char\u0026gt;, output_str:\u0026amp;mut String){ if let Some(c) = output_char{ output_str.push(c); } } } struct BfInterpreter{ token_array : Vec\u0026lt;Token\u0026gt;, token_ptr : u32, memory : Vec\u0026lt;u32\u0026gt;, memory_ptr: u16, input : VecDeque\u0026lt;char\u0026gt;, output : String, loop_start_end_token_ptr_map : HashMap\u0026lt;u32,u32\u0026gt;, loop_end_start_token_ptr_map : HashMap\u0026lt;u32,u32\u0026gt;, } impl BfInterpreter{ fn init(src: \u0026amp;str, input: \u0026amp;str) -\u0026gt; BfInterpreter { let ta = Token::tokenize_from_array(src.chars().collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;()); let (lsetpm,lestpm) = Token::get_loop_token_ptr(\u0026amp;ta); BfInterpreter{ token_array : ta, token_ptr : 0, //Brainf*ck\u0026#39;s number of memory cell is defined to be larger than 30,000.  //So this program should reserve size of \u0026#39;u16::max_value()\u0026#39;,  //which is expected to be 2^16 - 1 = 65,535.  memory : vec![0 ; u16::max_value() as usize], memory_ptr : 0, input : input.chars().collect(), output : String::from(\u0026#34;\u0026#34;), loop_start_end_token_ptr_map : lsetpm, loop_end_start_token_ptr_map : lestpm, } } fn exec(\u0026amp;mut self){ let token_array = \u0026amp;self.token_array; while let Some(token) = token_array.get(self.token_ptr as usize){ match *token{ Token::Inc =\u0026gt; { Token::inc_mem_val(\u0026amp;mut self.memory, self.memory_ptr); } Token::Dec =\u0026gt; { Token::dec_mem_val(\u0026amp;mut self.memory, self.memory_ptr); } Token::IncPtr =\u0026gt; { Token::inc_mem_ptr(\u0026amp;mut self.memory_ptr); } Token::DecPtr =\u0026gt; { Token::dec_mem_ptr(\u0026amp;mut self.memory_ptr); } Token::StartLoop =\u0026gt; { Token::jump_loop_end_token_if_mem_0( self.memory.get(self.memory_ptr as usize), \u0026amp;self.loop_start_end_token_ptr_map, \u0026amp;mut self.token_ptr ); } Token::EndLoop =\u0026gt; { Token::jump_loop_start_token_if_mem_not_0( self.memory.get(self.memory_ptr as usize), \u0026amp;self.loop_end_start_token_ptr_map, \u0026amp;mut self.token_ptr ); } Token::Input =\u0026gt; { Token::put_char_from_input_to_mem( \u0026amp;mut self.input, \u0026amp;mut self.memory, self.memory_ptr ); } Token::Output =\u0026gt; { Token::join_output_char_to_str( self.memory.get(self.memory_ptr as usize) .and_then(|i| std::char::from_u32(*i)), \u0026amp;mut self.output); } } self.token_ptr += 1; } } fn output(\u0026amp;self)-\u0026gt;\u0026amp;str{ return \u0026amp;self.output; } } fn main (){ let src: \u0026amp;str = \u0026#34;+++++++++[\u0026gt;++++++++\u0026gt;+++++++++++\u0026gt;+++++\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;.\u0026gt;++.+++++++..+++.\u0026gt;-. ------------.\u0026lt;++++++++.--------.+++.------.--------.\u0026gt;+.\u0026#34;; let input : \u0026amp;str = \u0026#34;\u0026#34;; let mut bf = BfInterpreter::init(src, input); bf.exec(); println!(\u0026#34;{}\u0026#34;,bf.output()); } このコードの実行結果はもちろん\nHello, world! となる。\nRustでこの「Hello, world!プログラム」を書いた感想として、\n Rustで難解と言われる所有権やライフタイム、借用などは、横着せずにきちんと設計を考えればそれほど問題にはならない。 Rustはコンパイラが出すエラーメッセージが分かりやすいので、コンパイルエラーの修復はむしろ他の言語よりも楽であることが多かった。 RustはC++をよりモダンで安全に1した感じの言語だと感じた。その点でC++に多少なりとも慣れ親しんだプログラマ2に向いている言語だと感じた。 結論として、Rustは書いていて愉しい言語であった。  なお、上記のコードではそこから以下の点で高速化を図っている。\n Brainf*ckコード読み込み時のトークナイズ ループ位置のメモ化3  参考図書     そして少し過保護に\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 例えば私のような\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 上記トークナイズ処理時、[トークンの位置と対応する]トークンの位置をハッシュテーブルに載せる。そうすることで実行時に対応するループ位置へのジャンプが高速化できることが期待される\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2019/07/rust-brainfxxk-interpreter/"},{"title":"Notepad++の64bit版でメモ帳を置き換える際の注意点","date":"","description":"","body":"tepad++はv7.5.9より、Windows標準のメモ帳を「置き換える」((正確にはメモ帳を起動しようとするとメモ帳の代わりにNotepad++が立ち上がる))ことが可能になっている。\n参考：\n「メモ帳」として起動できるようになった無料テキストエディター「Notepad++」v7.5.9／「メモ帳」に関連付けられたファイルを「Notepad++」で開くことが可能 https://t.co/anniPJyZQl pic.twitter.com/99n3kwKoMK\n\u0026mdash; 窓の杜 (@madonomori) October 16, 2018  しかし、公式サイトやそれを継承した窓の杜の記事の方法は32bit版のものであり、64bit版を使用している場合は失敗してしまう1ので注意が必要\n具体的には、公式サイトで紹介されている\nreg add \u0026quot;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe\u0026quot; /v \u0026quot;Debugger\u0026quot; /t REG_SZ /d \u0026quot;\\\u0026quot;%ProgramFiles(x86)%\\Notepad++\\notepad++.exe\\\u0026quot; -notepadStyleCmdline -z\u0026quot; /f では、Notepad++のインストール先として32bit版のそれであるProgram Files(x86)フォルダが指定されている。それを64bit版に書き換えて\nreg add \u0026quot;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe\u0026quot; /v \u0026quot;Debugger\u0026quot; /t REG_SZ /d \u0026quot;\\\u0026quot;%ProgramFiles%\\Notepad++\\notepad++.exe\\\u0026quot; -notepadStyleCmdline -z\u0026quot; /f とする。 そして上記コマンドを管理者権限のコマンドプロンプトで実行すれば、無事置き換えが完了する。\n   メモ帳を起動しようとするとnotepad++.exeが見つからない旨のエラーが発生する。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/2019/06/replace-notepad-to-npp/"},{"title":"JavascriptでYYYY/MM/DDみたいな形式で出力＋日本語の曜日を手軽に出力","date":"","description":"","body":"月や日付を2ケタに揃えて出したり、曜日を漢字1字で出したりする。 割とよく使うコードなのでsnippet的に。\nvar today = new Date(); var year = (today.getFullYear()).toString(); var month = (\u0026#34;0\u0026#34; + (today.getMonth()+1).toString()).slice(-2); var date = (\u0026#34;0\u0026#34; + today.getDate().toString()).slice(-2); var dayOfWeek = \u0026#34;日月火水木金土\u0026#34;.slice(today.getDay(), today.getDay() + 1); console.log( year + \u0026#34;年\u0026#34; + month + \u0026#34;月\u0026#34; + date + \u0026#34;日（\u0026#34; + dayOfWeek + \u0026#34;）\u0026#34; ); のようにしてやると\n2019年06月20日（木） のように出力される。\nドメイン期限切れのアラートメールが届くまで、このブログの存在を完全に忘れていた。完全な三日坊主である。\n","ref":"/blog/2019/06/javascript-formatted-date/"},{"title":"LaTeXでパワポみたいなハンドアウト（配布資料）を作る","date":"","description":"","body":"プレゼンテーションの際にPowerPointではハンドアウトとして1枚の紙に4枚や6枚などのスライドを印刷したものを配ることが多い． BeamerなどLaTeXでスライドを作成している場合も，そういったPowerPointのようなハンドアウトもできればLaTeXで作りたい． そういう時の解決法．\npdfpagesパッケージを使ってスライドのPDF（下記のコードではmain.pdf）を読み込んで配置する．\n\\documentclass[dvipdfmx,uplatex,a4j,landscape]{jsarticle} \\usepackage[top=12.7truemm,bottom=12.7truemm,left=12.7truemm,right=12.7truemm,landscape]{geometry} \\usepackage{pdfpages} \\begin{document} \\includepdf[pages=-,nup=2x2,frame,noautoscale,delta=5mm 8mm]{main.pdf} %横に2x2の4枚 \\end{document} こんな感じのLaTeX文書を書くと\n      こんな感じのハンドアウトができる．\n簡単に解説すると，\\includepdfのnupオプションで並べる枚数（ここでは2x2の4枚）を指定し，frameオプションで枠を付け，noautoscaleおよびdeltaオプションで各スライド間の余白を作っている．\n","ref":"/blog/2018/11/latex-handout/"},{"title":"LaTeXで目次にページ番号のない独自項目を追加する","date":"","description":"","body":"一般的にLaTeXで目次に独自の項目を追加するには，\\addcontentslineを用いるのが一般的である． しかしこのやり方では，ページ番号が自動的に付加されてしまう．これはページ番号を出力したくない場合には不便である．そういう時の解決法．\n\\usepackage{tocloft} した上で\n\\cftaddtitleline{toc}{section}{\\numberline{番号}{セクション名}{} すると\\addcontentsするよりも楽．\n","ref":"/blog/2018/11/latex-addcontentsline-without-page-no/"},{"title":"LaTeXでテーブル（表）のキャプションをカスタマイズする","date":"","description":"","body":"LaTeXの表（table環境）でキャプションを左寄せにするなど，カスタマイズする方法について．\n具体的には\n      こういう表を\n      こんな感じにしたい． （例としてキャプションを左寄せ，「表2」を太字にしてその後にピリオドを付加）\n解決法 threeparttableパッケージと captionパッケージを使用する． どちらもTeXLiveにはデフォルトで入ってるはず．\n\\documentclass[uplatex,a4j]{jsarticle} \\usepackage{threeparttable} \\usepackage{caption} \\captionsetup[table]{labelsep=period, labelfont=bf, justification=raggedright, singlelinecheck=off} \\begin{document} \\begin{table}[ht] \\centering \\begin{threeparttable} \\caption{キャプションが左寄せの表} \\begin{tabular}{|l|l|l|l|} \\hline ほげほげほげ \u0026amp; ほげほげほげ \u0026amp; ほげほげほげ \u0026amp; ほげほげほげ \\\\ \\hline ああああ \u0026amp; いいいい \u0026amp; うううう \u0026amp; ええええ \\\\ \\hline \\end{tabular} \\end{threeparttable} \\end{table} \\end{document} こんな感じ．\nキャブションをカスタマイズするには\n\\captionsetup[table]{labelsep=period, labelfont=bf, justification=raggedright, singlelinecheck=off} の部分をいじれば良い．簡単に解説すると\n labelsep:\n「表n」部分とそれ以降のテキスト部分の間を何で区切るか．period(ピリオド)以外にもspace(スペース)，colon(コロン)，newline(改行)などがある． labelfont:\n「表n」部分のフォントをどうするか．bf(太字)以外にも斜体にしたりフォントサイズを変えたり色々できる．テキスト部分も一緒に変えたい場合はfontを，テキスト部分のみ変えたい場合はtextfontを使う． justification:\nキャプションをどこに寄せるか．ややこしいようだがraggedrightで左，centeringで中央，raggedleftで右に寄せられる． singlelinecheck:\nLaTeXのドキュメントクラスはキャプションが1行の場合，自動的に中央に寄せるようになる．それをoffでオフにする．上記のjustificationを使用する場合，ほとんどの場合で必須．  このほかにもマージンのカスタマイズなど，様々なオプションが用意されているので，詳しくは公式ドキュメント(PDF)を参照して欲しい．\n","ref":"/blog/2018/11/latex-table-caption/"},{"title":"LaTeXでビジネス文書を書く","date":"","description":"","body":"LaTeXでビジネス文章を書くためのテンプレート的な，ちょっとしたスタイルファイルを書いた1．\nスタイルファイルの詳細やダウンロード等はGitHubへ．\n使用例 \\documentclass[uplatex,a4j,fleqn,12pt]{jsarticle} \\usepackage[top=35.01truemm,bottom=30truemm,left=30truemm,right=30truemm]{geometry} \\usepackage{jbusinessdoc} %\\documentnumber{文章番号第42号} \\date{平成yy年mm月dd日} \\destination{○○株式会社\\\\ご担当者様} \\author{××株式会社\\\\ほげほげ} \\title{ほげほげのご案内} \\begin{document} \\maketitle \\begin{haikei} 時下ますますご清栄のこととお喜び申し上げます。 平素はひとかたならぬお引き立てを賜り、厚く御礼申し上げます。 さて、このたび弊社ではほげほげがふがふがとなりました。 つきましては、ほげほげの程よろしくお願い申し上げます。 \\end{haikei} \\begin{kigaki} \\begin{itemize} \\item 日時：いつか \\item 会場：どっか \\end{itemize} \\end{kigaki} \\end{document} こんな感じでLaTeX文書を書くと\n   ビジネス文章っぽい    こんな感じで出力される．\n使い方  普通のLaTeX文章を用意する（pLaTeXもしくはupLaTeXでjsarticleを使用することを想定してるので，それ以外だと上手く動かないかも）． ここからjbusinessdoc.styをダウンロードする jbusinessdoc.sty をそのLaTeX文書のビルドが通る場所（例えば.texファイルと同じディレクトリ）に置く プリアンブルに\\usepackage{jbusinessdoc}と書く \\title，\\author，\\dateのほかに，宛先を書くための\\destinationを書く 必要があれば文章番号となる\\documentnumberも書く（省略可） 普通のLaTeXファイルと同じようにビルドする  その他 「こういうビジネス文書を作りたいけどWordは使いたくない，できればLaTeXで書きたい」って人は（自分の他にも）意外と多いんじゃないかと思ってググったけど，それらしいノウハウがあまり出てこなかったので，そういう人の役に立てば．\n参考図書    正確に言えば以前必要に迫られて書いたものを，せっかく始めたブログのネタにでもと思いスタイルファイルとして独立させた．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","ref":"/blog/2018/11/writing-japanese-business-documents-in-latex/"},{"title":"Hello, Cluttered World!","date":"","description":"","body":"なんとなくブログもどきを作ってみた。\n面白ドメインを探していたら「clutte.red」（cluttered = 雑然とした・散らかった）というドメインを取ってしまったのと、ちょっとした知見等を誰かのために共有する場所があれば良いなあと以前から思っていたので。\n","ref":"/blog/2018/11/hello-world/"},{"title":"Contact","date":"","description":"","body":"","ref":"/contact/"}]